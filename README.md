## 线程学习备忘：

#### 基础概念部分

------------

##### 1.java内存模型
`由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。`

##### 2.线程基础概念
__`线程安全`__：`当多个线程访问同一个类时，无论出于何种环境，采用何种调度方式，或者多个线程将如何的调度执行，而代码中不需要额外的同步或者协同方式，这个类都可以表现出正常的行为得到预期相同的结果，那么就称这个类是线程安全的。`

__`线程安全主要变现在以下几个方面：`__
- __`a.原子性`__：`提供了互斥访问，同一时刻只允许一个线程来对它进行操作`
- __`b.可见性`__：`一个线程对主内存数据的修改，可以及时的被其他线程观察到`
- __`c.有序性`__：`一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序`

__`原子性关键字：synchronized`__:
- __`a.修饰代码块`__：`大括号括起来的代码，作用于调用的对象`
- __`b.修饰方法`__：`整个方法，作用于调用的对象`
- __`c.修饰静态方法`__：`修饰整个静态方法，作用于改类的所有的对象`
- __`d.修饰类`__：`修饰整个类，作用于改类的所有的对象`

__`synchronized、lock、Atoic之间的对比`__:
- __`synchronized`__：`不可中断锁，竞争不激烈，可读性高，竞争激烈时，执行效率差，需等待一个线程执行完成以后才会进行下次执行`
- __`lock`__：`可中断（unlock方法），多样化同步，竞争激烈时可维持常态`
- __`Atomic`__：`性能比lock好，但是只可以维护一个变量`

__`JVM关于synchernize的两条规定`__:
- `线程解锁前，必须把共享变量的值刷新到主内存中`
- `线程加锁时，清空工作空间中的共享变量，从而使需要使用到共享变量的时候，需要去主内存中获取最新的值（加锁和解锁使用的是同一把锁）`

__`可见性关键字：volatile`__:
`被volatile 修饰的变量，在进行读写操作的时候，都会将工作空间中最新的值同步到主内存（无法保证线程安全）,volatile 不具有原子性`

__`不可变对象final`__:
- `对象创建以后其状态就不可更改`
- `对象的所有域都是final类型`
- `对象是正确创建的（在对象创建期间，this引用没有溢出）`

__`final写法`__ :
`将类声明为final使类不可继承，将所有的成员设置为私有属性，不可被外部访问，对变量不提供set方法，对所有的可变成员声明为final，通过构造器初始化所有的成员进行深度拷贝，提供get方法不返回对象本身，而是返回对象的拷贝。fianl修饰引用对象，对象不可重新指向其他对象，但是数据可以更改`

__`线程封闭`__:
- `ThreadLocal用法详解和原理:ThreadLocal并不是一个Thread，而是Thread的局部变量`

__`常用java类的线程情况`__:
- `StringBuff 为线程安全，StringBuilder 为线程不安全类`
- `ArrayList 线程不安全，HashSet 线程不安全，HashMap 线程不安全`

__`同步容器类`__:
- `ArrayList -> Vector（被synchronized 修饰）、Stack`
- `HashMap -> HashTable（被synchronized 修饰`
- `Collections -> Collection.synchronizedXxx`
- `注意：当一个线程对一个集合进行遍历，而另一个线程对该集合进行增删操作会引发异常，建议遍历时标记需要更新的元素，在遍历结束之后再进行更新（foreach和ierator会引发，for循环不会）`

__`并发容器类（J.U.C）`__:
- `ArrayList -> CopyOnWriteArrayList 先从原由的数据中拷贝一份，在新的数组上进行更行操作，完成后再将原来的对象指向新的对象，这些操作都在锁的保护下进行的，防止复制出多个副本。适合读多写少的操作，但是内存开销大。特点：读写分离，最终一致性，使用时另外开辟空间防止线程并发。`
- `HashSet、TreeSet -> CopyOnWriteArraySet、ConcurrentSkipListSet`
- `HashMap、TreeMap -> ConcurrentHashMap、ConcurrentSkipListMap`

__`线程池`__:
__`传统的new Thread() 方法弊端`__:
- `每次新建对象，导致性能很差`
- `线程缺乏统一的管理，可能导致无限制的新建线程，相互竞争，导致系统宕机`
- `缺少更多的功能，更多执行、线程中断、定期执行`

__`线程池的优点`__:
- `重复使用线程，减少线程的创建销毁等的资源消耗`
- `可以有效的控制最大并发线程数、提高系统资源利用率、同时可以避免过多的竞争资源、避免阻塞`
- `提供定期执行、定时执行、单线程、并发控制数等高级功能`

__`线程池的常用类 ThreadPoolExecutor 的几个参数和方法释义`__:
    `corePoolSize: 核心线程数`   
    `maximumPoolSize: 线程最大线程数`   
    `workQueue: 阻塞队列，存储等待执行的任务，会对线程池的运行过程产生重大影响(决定任务的处理方式)`    
    `corePoolSize > 线程数量 即使有空闲线程，也会创建新的线程处理任务; corePoolSize <= 线程数量 < maximumPoolSize && workQueue队列满了才会创建行的线程去执行任务 ; 如果 线程数量 = maximumPoolSize 那么等待空闲线程处理任务, 如果 线程数量 > maximumPoolSize采用策略执行任务。通过设置这三个参数，可以调优线程池，增加资源利用率，执行效率`    
    `keepAliveTime: 线程中没有任务时，最多保持多长时间终止`    
    `threadFactory: 线程工厂`    
    `execute(): 提交任务，交给线程池进行处理`    
    `submit() : 提交任务，并且可以获得执行结果`    
    `showdown(): 等待任务执行完，关闭线程池`     
    `showdownNow(): 关闭线程池，不等待任务执行完`
    
__`死锁`__:`死锁是指两个或者两个以上的进程，在争夺资源发生的互相等待的情况，此时，如果没有外力作用，它们将一直等待下去。`



















