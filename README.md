## 线程学习备忘：

#### 基础概念部分

------------

##### 1.java内存模型
`由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。`

##### 2.线程基础概念
__`线程安全`__：`当多个线程访问同一个类时，无论出于何种环境，采用何种调度方式，或者多个线程将如何的调度执行，而代码中不需要额外的同步或者协同方式，这个类都可以表现出正常的行为得到预期相同的结果，那么就称这个类是线程安全的。`

__`线程安全主要变现在以下几个方面：`__
- __`a.原子性`__：`提供了互斥访问，同一时刻只允许一个线程来对它进行操作`
- __`b.可见性`__：`一个线程对主内存数据的修改，可以及时的被其他线程观察到`
- __`c.有序性`__：`一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序`

__`原子性关键字：synchronized`__:
- __`a.修饰代码块`__：`大括号括起来的代码，作用于调用的对象`
- __`b.修饰方法`__：`整个方法，作用于调用的对象`
- __`c.修饰静态方法`__：`修饰整个静态方法，作用于改类的所有的对象`
- __`d.修饰类`__：`修饰整个类，作用于改类的所有的对象`

__`synchronized、lock、Atoic之间的对比`__:
- __`synchronized`__：`不可中断锁，竞争不激烈，可读性高，竞争激烈时，执行效率差，需等待一个线程执行完成以后才会进行下次执行`
- __`lock`__：`可中断（unlock方法），多样化同步，竞争激烈时可维持常态`
- __`Atomic`__：`性能比lock好，但是只可以维护一个变量`

__`JVM关于synchernize的两条规定`__:
- `线程解锁前，必须把共享变量的值刷新到主内存中`
- `线程加锁时，清空工作空间中的共享变量，从而使需要使用到共享变量的时候，需要去主内存中获取最新的值（加锁和解锁使用的是同一把锁）`

__`可见性关键字：volatile`__:
`被volatile 修饰的变量，在进行读写操作的时候，都会将工作空间中最新的值同步到主内存（无法保证线程安全）,volatile 不具有原子性`

__`不可变对象final`__:
- `对象创建以后其状态就不可更改`
- `对象的所有域都是final类型`
- `对象是正确创建的（在对象创建期间，this引用没有溢出）`
__`final写法`__ : `将类声明为final使类不可继承，将所有的成员设置为私有属性，不可被外部访问，对变量不提供set方法，对所有的可变成员声明为final，通过构造器初始化所有的成员进行深度拷贝，提供get方法不返回对象本身，而是返回对象的拷贝。fianl修饰引用对象，对象不可重新指向其他对象，但是数据可以更改`

